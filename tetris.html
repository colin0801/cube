<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ä¿„ç¾…æ–¯æ–¹å¡Š â€” å–®æª”ç¶²é ç‰ˆ</title>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --accent:#38bdf8;
    }
    *{box-sizing:border-box;font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans TC", Arial}
    body{margin:0; background:linear-gradient(180deg,#0b1022,#0f172a); color:var(--text); display:flex; min-height:100vh;}
    .wrap{margin:auto; display:grid; gap:16px; grid-template-columns: minmax(280px, min(70vw, 520px)) 1fr; align-items:start; padding:16px; width:100%; max-width:1100px}
    .panel{background:var(--panel); border:1px solid #243042; border-radius:16px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .title{display:flex; gap:10px; align-items:center; font-weight:700; letter-spacing:.5px}
    .title span{color:var(--accent)}
    .gridbox{position:relative; width:100%; aspect-ratio:10/20;}
    canvas{width:100%; height:100%; display:block; background:#0a1020; border-radius:12px;}
    .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:10px; background:rgba(0,0,0,.45); border-radius:12px}
    .overlay.hidden{display:none}
    .ov-title{font-size:26px; font-weight:800}
    .ov-sub{opacity:.9}

    .side{display:grid; gap:12px}
    .stats{display:grid; grid-template-columns:repeat(3,1fr); gap:8px; text-align:center}
    .stat{background:#0b1222; border:1px solid #2a3a50; border-radius:12px; padding:8px}
    .big{font-size:20px; font-weight:800}
    .boxes{display:grid; grid-template-columns:repeat(2,1fr); gap:8px}
    .box{background:#0b1222; border:1px solid #2a3a50; border-radius:12px; padding:8px}
    .box h3{margin:0 0 6px 0; font-size:14px; color:#9fb6d1}
    .mini{width:100%; aspect-ratio:1/1; background:#0a1020; border-radius:8px}
    .help{font-size:12px; line-height:1.4}
    code{background:#0a1020; padding:2px 6px; border-radius:6px; border:1px solid #223049}
    .btns{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
    .btn{padding:10px; border-radius:10px; background:#12223a; border:1px solid #2a3a50; color:var(--text); font-weight:700; cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .touch{display:none; gap:8px; grid-template-columns:repeat(4,1fr)}
    .tbtn{user-select:none; touch-action:manipulation; padding:14px 8px; border-radius:12px; text-align:center; background:#0f1e34; border:1px solid #2a3a50; font-weight:800}
    .tbtn:active{transform:translateY(1px)}
    @media (max-width: 900px){ .wrap{grid-template-columns:1fr} .touch{display:grid} .btns{grid-template-columns:repeat(2,1fr)} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="title">ğŸ® <span>Web Tetris</span> â€” ä¿„ç¾…æ–¯æ–¹å¡Š</div>
      <div class="gridbox">
        <canvas id="board" width="300" height="600"></canvas>
        <div id="overlayStart" class="overlay">
          <div class="ov-title">é»æ“Šæˆ–æŒ‰ä»»æ„éµé–‹å§‹</div>
          <div class="ov-sub">æç¤ºï¼šæ‰‹æ©Ÿå¯ç”¨ä¸‹æ–¹è§¸æ§éµï¼›é›»è…¦å¯ç”¨éµç›¤ â† â†’ â†“ â†‘ / Z X / Space / C</div>
          <button id="btnStart" class="btn" style="margin-top:6px">é–‹å§‹éŠæˆ²</button>
        </div>
        <div id="overlayPause" class="overlay hidden"><div class="ov-title">æš«åœä¸­</div><div class="ov-sub">æŒ‰ P / é»æ“Šç•«é¢ç¹¼çºŒ</div></div>
        <div id="overlayOver" class="overlay hidden"><div class="ov-title">GAME OVER</div><div class="ov-sub">æŒ‰ R é‡é–‹</div></div>
      </div>
      <div class="touch" aria-label="è§¸æ§æ§åˆ¶å™¨">
        <div class="tbtn" id="tLeft">â† å·¦</div>
        <div class="tbtn" id="tDown">â†“ è»Ÿé™</div>
        <div class="tbtn" id="tRight">â†’ å³</div>
        <div class="tbtn" id="tRotate">â†» æ—‹è½‰</div>
        <div class="tbtn" id="tHold">H ä¿ç•™</div>
        <div class="tbtn" id="tDrop">Space ç¡¬é™</div>
        <div class="tbtn" id="tPause">P æš«åœ</div>
        <div class="tbtn" id="tReset">R é‡é–‹</div>
      </div>
    </div>

    <div class="side">
      <div class="panel stats">
        <div class="stat"><div>åˆ†æ•¸</div><div id="score" class="big">0</div></div>
        <div class="stat"><div>ç­‰ç´š</div><div id="level" class="big">1</div></div>
        <div class="stat"><div>æ¶ˆè¡Œ</div><div id="lines" class="big">0</div></div>
      </div>

      <div class="panel boxes">
        <div class="box">
          <h3>ä¸‹ä¸€é¡†</h3>
          <canvas id="next" class="mini" width="120" height="120"></canvas>
        </div>
        <div class="box">
          <h3>ä¿ç•™ (Hold)</h3>
          <canvas id="hold" class="mini" width="120" height="120"></canvas>
        </div>
        <div class="box" style="grid-column:1/3">
          <h3>éµä½èªªæ˜</h3>
          <div class="help">
            <div><b>â† â†’</b>: å·¦/å³ç§»å‹•ã€€<b>â†“</b>: è»Ÿé™(+1/æ ¼)</div>
            <div><b>â†‘ / X</b>: æ—‹è½‰ã€€<b>Z</b>: é€†æ™‚é‡ã€€<b>Space</b>: ç¡¬é™(+2/æ ¼)</div>
            <div><b>Shift/C</b>: ä¿ç•™ã€€<b>P</b>: æš«åœã€€<b>R</b>: é‡æ–°é–‹å§‹</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="title">âš™ï¸ éŠæˆ²è¨­å®š</div>
        <div class="btns" style="margin-top:8px">
          <button class="btn" id="btnPause">æš«åœ/ç¹¼çºŒ (P)</button>
          <button class="btn" id="btnReset">é‡æ–°é–‹å§‹ (R)</button>
          <button class="btn" id="btnGhost">åˆ‡æ›å¹½éˆå½± (G)</button>
          <button class="btn" id="btnGrid">åˆ‡æ›æ ¼ç·š (B)</button>
          <button class="btn" id="btnSound">åˆ‡æ›éŸ³æ•ˆ (S)</button>
          <button class="btn" id="btnDas">ç§»å‹•åŠ é€Ÿ (DAS)</button>
        </div>
      </div>

      <div class="panel">
        <div class="title">ğŸ“Œ é–‹ç™¼è€…èªªæ˜</div>
        <div class="help">
          <ul>
            <li>10Ã—20 æ£‹ç›¤ã€7-Bag éš¨æ©Ÿã€ç°¡åŒ– SRS æ—‹è½‰ã€‚</li>
            <li>è¨ˆåˆ†ï¼šå–®/é›™/ä¸‰/å››æ¶ˆ=100/300/500/800ï¼›è»Ÿé™+1/æ ¼ã€ç¡¬é™+2/æ ¼ã€‚</li>
            <li>æ¯ 10 è¡Œå‡ç´šä¸€æ¬¡ï¼Œç­‰ç´šæå‡ä¸‹è½é–“éš”æœƒç¸®çŸ­ã€‚</li>
            <li>è¡Œå‹•è£ç½®æä¾›è§¸æ§æŒ‰éˆ•ï¼ŒPC ç”¨éµç›¤æ“ä½œã€‚</li>
            <li>ç¨‹å¼ç‚ºå–®æª”ï¼šå¦å­˜æˆ <code>tetris.html</code> é›¢ç·šç©ã€‚</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* =====================================================
   *  ä¿„ç¾…æ–¯æ–¹å¡Š â€” å–®æª”ç¶²é ç‰ˆ
   *  Ver: 1.0.1 (2025-08-08) â€” ä¿®æ­£ï¼šåœ¨ Page/æ‰‹æ©Ÿä¸Šã€Œæœ‰ç•«é¢ä½†ä¸é–‹å§‹ã€â†’ æ”¹æˆéœ€æ‰‹å‹¢å•Ÿå‹•
   * ===================================================== */
  const COLS=10, ROWS=20, BLOCK=30;
  const board = document.getElementById('board');
  const ctx = board.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const holdCtx = holdCanvas.getContext('2d');
  const $ = id=>document.getElementById(id);

  // ç‹€æ…‹
  let grid, bag, queue, current, hold, holdLocked, dropTimer, dropInterval, lastTime, running, ghostOn, gridOn, soundOn, score, lines, level, isGameOver;
  let started=false; // éœ€è¦ä½¿ç”¨è€…æ‰‹å‹¢å•Ÿå‹•ï¼ˆè§£æ±ºæŸäº›ç€è¦½å™¨ rAF/Audio é™åˆ¶ï¼‰

  // WebAudioï¼ˆåƒ…åœ¨äº’å‹•å¾Œå»ºç«‹ï¼Œé¿å…è¢«å°é–ï¼‰
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx=null;
  function playTick(){ if(!soundOn || !audioCtx) return; playTone(220,0.01); }
  function playTone(freq=440, dur=0.05){
    if(!soundOn || !audioCtx) return;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.frequency.value=freq; o.type='square'; o.connect(g); g.connect(audioCtx.destination);
    const now=audioCtx.currentTime; g.gain.setValueAtTime(0.08, now); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    o.start(); o.stop(now+dur);
  }

  // ====== åˆå§‹åŒ– ======
  function initGameState(){
    grid = createMatrix(COLS, ROWS, 0);
    bag=[]; queue=[]; current=null; hold=null; holdLocked=false; isGameOver=false;
    score=0; lines=0; level=1; dropInterval=1000; dropTimer=0; running=true; lastTime=0;
    nextType(); spawn(); drawHold(); updateInfo(); draw();
  }

  function startGame(){
    if(started) return; started=true;
    if(AudioCtx && !audioCtx) audioCtx = new AudioCtx();
    $('#overlayStart').classList.add('hidden');
    initGameState();
    requestAnimationFrame(loop);
  }

  // ====== ä¸»å¾ªç’° ======
  function loop(time=0){
    const delta = time - lastTime; lastTime = time;
    if(running){
      dropTimer += delta;
      handleAutoRepeat(delta);
      if(dropTimer >= dropInterval){ stepDown(); dropTimer = 0; }
    }
    draw();
    if(started) requestAnimationFrame(loop);
  }

  // ====== æ£‹ç›¤èˆ‡ç¹ªåœ– ======
  function createMatrix(w,h,val=0){return Array.from({length:h},()=>Array(w).fill(val));}
  function draw(){
    ctx.clearRect(0,0,board.width,board.height);
    ctx.fillStyle = '#0a1020'; ctx.fillRect(0,0,board.width,board.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const v=grid[y][x]; if(v) drawBlock(x,y,COLORS[v-1]); }
    if(current && ghostOn){ const d=ghostY(); forEachBlock(current,(x,y)=>drawBlock(x,y+d,'#1f2937')); }
    if(current){ forEachBlock(current,(x,y)=>drawBlock(x,y,current.color)); }
    if(gridOn){ ctx.strokeStyle='#162033'; ctx.lineWidth=1; for(let x=1;x<COLS;x++) line(x*BLOCK,0,x*BLOCK,ROWS*BLOCK); for(let y=1;y<ROWS;y++) line(0,y*BLOCK,COLS*BLOCK,y*BLOCK); }
    if(!running && isGameOver){ $('#overlayOver').classList.remove('hidden'); }
    else if(!running && started){ $('#overlayPause').classList.remove('hidden'); }
    else { $('#overlayPause').classList.add('hidden'); $('#overlayOver').classList.add('hidden'); }
  }
  function drawBlock(x,y,color){ ctx.fillStyle=color; ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK); ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,6); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(x*BLOCK,(y+1)*BLOCK-6,BLOCK,6); }
  function line(x1,y1,x2,y2){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}

  // ====== ä¸‹è½ã€ç¢°æ’ã€åˆä½µ ======
  function stepDown(){ if(!current) spawn(); current.y++; if(collide()){ current.y--; merge(); clearLines(); dropTimer=0; holdLocked=false; spawn(); if(collide()){ running=false; isGameOver=true; playTone(100,0.2);} } }
  function collide(){ let hit=false; forEachBlock(current,(x,y)=>{ if(y>=ROWS || x<0 || x>=COLS || (y>=0 && grid[y][x])) hit=true; }); return hit; }
  function merge(){ forEachBlock(current,(x,y)=>{ if(y>=0) grid[y][x]=colorIndex(current.color)+1; }); }
  function colorIndex(hex){return COLORS.findIndex(c=>c===hex);}    
  function clearLines(){ let cleared=0; outer: for(let y=ROWS-1;y>=0;y--){ for(let x=0;x<COLS;x++) if(!grid[y][x]) continue outer; grid.splice(y,1); grid.unshift(Array(COLS).fill(0)); cleared++; y++; }
    if(cleared>0){ const pts=[0,100,300,500,800][cleared]; score+=pts; lines+=cleared; level=1+Math.floor(lines/10); dropInterval=Math.max(80,1000-(level-1)*70); updateInfo(); playTone(660,0.05);} }
  function forEachBlock(p,fn){ const m=rotateMatrix(p.shape,p.rot); for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if(m[y][x]) fn(p.x+x, p.y+y); }

  // ====== ç”Ÿæˆã€æ—‹è½‰ã€ä½ç§» ======
  const SHAPES=[ [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[1,0,0],[1,1,1],[0,0,0]], [[0,0,1],[1,1,1],[0,0,0]], [[1,1],[1,1]], [[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[1,1,1],[0,0,0]], [[1,1,0],[0,1,1],[0,0,0]] ];
  const COLORS=['#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000','#334155'];
  function spawn(){ const type=nextType(); const shape=SHAPES[type]; const color=COLORS[type]; const size=shape[0].length; current={x:Math.floor((COLS-size)/2), y:-2, shape, rot:0, color, type}; }
  function nextType(){ while(queue.length<5){ if(bag.length===0) bag=shuffle([0,1,2,3,4,5,6]); queue.push(bag.pop()); } const t=queue.shift(); drawNext(); return t; }
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a;}
  function rotate(dir){ if(!current) return; const old=current.rot; current.rot=(current.rot+dir+4)%4; const kicks=[{x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:-1},{x:2,y:0},{x:-2,y:0}]; const ox=current.x, oy=current.y; for(const k of kicks){ current.x=ox+k.x; current.y=oy+k.y; if(!collide()){ playTone(520,0.02); return; } } current.x=ox; current.y=oy; current.rot=old; }
  function move(dx){ if(!current) return; current.x+=dx; if(collide()) current.x-=dx; else playTick(); }
  function softDrop(){ if(!current) return; current.y++; if(collide()) current.y--; else { score+=1; updateInfo(); } }
  function hardDrop(){ if(!current) return; let dist=0; while(true){ current.y++; if(collide()){ current.y--; break;} dist++; } score+=dist*2; updateInfo(); merge(); clearLines(); holdLocked=false; spawn(); dropTimer=0; playTone(300,0.03); if(collide()){ running=false; isGameOver=true; } }
  function ghostY(){ if(!current) return 0; const temp={...current}; while(true){ temp.y++; if(checkCollide(temp)){ temp.y--; break;} } return temp.y-current.y; }
  function checkCollide(p){ let hit=false; forEachBlock(p,(x,y)=>{ if(y>=ROWS || x<0 || x>=COLS || (y>=0 && grid[y][x])) hit=true; }); return hit; }
  function holdPiece(){ if(holdLocked) return; if(hold===null){ hold=current.type; spawn(); } else { const t=hold; hold=current.type; const shape=SHAPES[t]; const color=COLORS[t]; const size=shape[0].length; current={x:Math.floor((COLS-size)/2), y:-2, shape, rot:0, color, type:t}; } holdLocked=true; drawHold(); playTone(420,0.02); }
  function rotateMatrix(mat,rot){ let m=mat; if(rot===0) return m; const size=Math.max(m.length, m[0].length); const sq=Array.from({length:size}, (_,y)=>Array(size).fill(0)); for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++) sq[y][x]=m[y][x]; m=sq; for(let r=0;r<rot;r++){ const t=Array.from({length:size},()=>Array(size).fill(0)); for(let y=0;y<size;y++) for(let x=0;x<size;x++) t[x][size-1-y]=m[y][x]; m=t; } return trimMatrix(m); }
  function trimMatrix(m){ let top=0,bottom=m.length-1,left=0,right=m[0].length-1; const isRowZero=r=>m[r].every(v=>v===0); const isColZero=c=>m.every(row=>row[c]===0); while(top<=bottom && isRowZero(top)) top++; while(bottom>=top && isRowZero(bottom)) bottom--; while(left<=right && isColZero(left)) left++; while(right>=left && isColZero(right)) right--; const res=[]; for(let y=top;y<=bottom;y++){ res.push(m[y].slice(left,right+1)); } return res.length?res:[[1]]; }

  // ====== Next/Hold é¡¯ç¤º ======
  function drawNext(){ const type=queue[0]; const shape=SHAPES[type]; const color=COLORS[type]; drawMini(nextCtx, nextCanvas, shape, color); }
  function drawHold(){ holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height); if(hold===null) return; const shape=SHAPES[hold]; const color=COLORS[hold]; drawMini(holdCtx, holdCanvas, shape, color); }
  function drawMini(c, canvas, shape, color){ const m=trimMatrix(shape); const size=Math.max(m.length, m[0].length); const cell=Math.floor((canvas.width-10)/size); const offX=Math.floor((canvas.width-cell*size)/2); const offY=Math.floor((canvas.height-cell*size)/2); c.fillStyle='#0a1020'; c.fillRect(0,0,canvas.width,canvas.height); for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++) if(m[y][x]){ c.fillStyle=color; c.fillRect(offX+x*cell, offY+y*cell, cell, cell); c.fillStyle='rgba(255,255,255,0.1)'; c.fillRect(offX+x*cell, offY+y*cell, cell, 4); c.fillStyle='rgba(0,0,0,0.25)'; c.fillRect(offX+x*cell, offY+(y+1)*cell-4, cell, 4);} }

  // ====== ä»‹é¢/è³‡è¨Š ======
  function updateInfo(){ $('#score').textContent=score; $('#lines').textContent=lines; $('#level').textContent=level; }
  function togglePause(){ if(isGameOver || !started) return; running=!running; if(!running) { $('#overlayPause').classList.remove('hidden'); if(audioCtx) playTone(120,0.05);} else { $('#overlayPause').classList.add('hidden'); } }

  // ====== éµç›¤èˆ‡è§¸æ§ ======
  const moveState={left:false,right:false,down:false}; let dasDelay=140, arr=25; let dasTimers={left:0,right:0};
  document.addEventListener('keydown', e=>{
    if(!started){ startGame(); }
    if(e.key===' '){ e.preventDefault(); }
    if(e.repeat) return;
    switch(e.key){
      case 'ArrowLeft': move(-1); moveState.left=true; dasTimers.left=0; break;
      case 'ArrowRight': move(1); moveState.right=true; dasTimers.right=0; break;
      case 'ArrowDown': moveState.down=true; softDrop(); break;
      case 'ArrowUp': case 'x': case 'X': rotate(1); break;
      case 'z': case 'Z': rotate(-1); break;
      case 'Shift': case 'c': case 'C': holdPiece(); break;
      case 'p': case 'P': togglePause(); break;
      case 'r': case 'R': initGameState(); break;
      case 'g': case 'G': ghostOn=!ghostOn; break;
      case 'b': case 'B': gridOn=!gridOn; break;
      case 's': case 'S': soundOn=!soundOn; if(soundOn && !audioCtx && AudioCtx) audioCtx=new AudioCtx(); break;
    }
  });
  document.addEventListener('keyup', e=>{ if(e.key==='ArrowLeft') moveState.left=false; if(e.key==='ArrowRight') moveState.right=false; if(e.key==='ArrowDown') moveState.down=false; });

  // è§¸æ§æŒ‰éˆ•åŒæ™‚å¯å•Ÿå‹•
  $('#btnStart').onclick=()=>startGame();
  $('#board').onclick=()=>{ if(!started) startGame(); else togglePause(); };
  $('#tLeft').onclick = ()=>{ if(!started) startGame(); move(-1); };
  $('#tRight').onclick= ()=>{ if(!started) startGame(); move(1); };
  $('#tDown').onclick = ()=>{ if(!started) startGame(); softDrop(); };
  $('#tRotate').onclick=()=>{ if(!started) startGame(); rotate(1); };
  $('#tDrop').onclick = ()=>{ if(!started) startGame(); hardDrop(); };
  $('#tHold').onclick = ()=>{ if(!started) startGame(); holdPiece(); };
  $('#tPause').onclick= ()=>{ if(!started) startGame(); togglePause(); };
  $('#tReset').onclick= ()=>{ if(!started) startGame(); initGameState(); };
  $('#btnPause').onclick=()=>togglePause();
  $('#btnReset').onclick=()=>initGameState();
  $('#btnGhost').onclick=()=>ghostOn=!ghostOn;
  $('#btnGrid').onclick =()=>gridOn=!gridOn;
  $('#btnSound').onclick=()=>{ soundOn=!soundOn; if(soundOn && !audioCtx && AudioCtx) audioCtx=new AudioCtx(); };
  $('#btnDas').onclick=()=>{ dasDelay=(dasDelay===140?90:140); arr=(arr===25?18:25); };

  function handleAutoRepeat(delta){ for(const dir of ['left','right']){ if(moveState[dir]){ dasTimers[dir]+=delta; if(dasTimers[dir]>=dasDelay){ dasTimers[dir]-=arr; move(dir==='left'?-1:1);} } else dasTimers[dir]=0; } if(moveState.down) softDrop(); }

  // ====== è¦–çª—ç¸®æ”¾ ======
  function resize(){ board.width = COLS*BLOCK; board.height = ROWS*BLOCK; }
  addEventListener('resize', resize); resize();

  // åˆå§‹æ——æ¨™
  ghostOn=true; gridOn=true; soundOn=false;

  </script>
</body>
</html>
